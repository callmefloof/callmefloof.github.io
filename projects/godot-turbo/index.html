<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1" name=viewport><title>Joëlle Ubink – Game Dev Portfolio</title><link href=/style.css rel=stylesheet><link href=https://youtube.com rel=prefetch><body class=crt><svg viewbox="0 0 200 200" style=width:0;height:0;position:absolute><defs><filter height=200% id=crt-warp width=200% x=-50% y=-50%><feturbulence basefrequency="0.01 0.015" numoctaves=1 result=turb seed=2 type=fractalNoise /><fedisplacementmap in=SourceGraphic in2=turb scale=4 xchannelselector=R ychannelselector=G /></filter></defs></svg><header class=main-header><div class=post-header><a href=/>Home</a><a href=/blog>Blog</a></div><div class=toggle><input checked id=effects-on name=effects type=checkbox><label for=effects-on>Toggle Effects</label></div></header><div class=crt-bg></div><main class=post><h1 class=title>Godot Turbo</h1><hr><p class=tags><strong>Tags: </strong> C++, Godot, Flecs, Engine, Solo Project<p class=subtitle><strong></strong><hr><div class=youtube-video><iframe allowfullscreen loading=lazy mozallowfullscreen src=https://www.youtube.com/embed/P6AEflA3roU webkitallowfullscreen></iframe></div><h1 id=project-link><a href=https://github.com/callmefloof/godot-turbo>Project Link</a></h1><p>I made this module to have access to a fast, reliable ECS that could be integrated on a close level with Godot. I chose <a href=https://github.com/SanderMertens/flecs>FLECS</a> because of its rich feature set and performance. Godot had other options and alternatives for implementing a ECS. These solutions however did not satify my requirements of having a low-level, well-optimized ECS being statically linked to Godot. Static linking provides the opportunity to simplify porting to Consoles as dynamic linking is not permitted on those platforms.<p>Initially I created an implentation relying on extending the Godot <a href=https://docs.godotengine.org/en/stable/classes/class_resource.html>Resource</a> class as it provided a convenient way to write a reflection layer. This did not end up working due to the memory size and heap allocated nature of the underlying RefCounted and Object class. When creating or destroying a lot of instances at once memory would not be cleared quickly enough for it to add up. This caused the memory usage to spike above 40gbs.<p>I then scrapped most of the work done on the class structure and revised it to be a <a href=https://docs.godotengine.org/en/stable/engine_details/architecture/custom_godot_servers.html>Godot Server</a>, relying on <a href=https://docs.godotengine.org/en/stable/classes/class_rid.html>resource ID's</a> to allow GDScript users to access Flecs via the <a href=https://github.com/callmefloof/godot-turbo/blob/main/ecs/flecs_types/flecs_server.h>FlecsServer</a> class.<p>I also experimented with making a system to individually cull Multimesh instances, but this proved to be too challenging. I could not find update the buffer on the GPU with computed frustum and occlusion culling results without having significant framerate issues.<p>To test if it would work, I made a system rendering Bad Apple as spaced grid of cubes managed through a multimesh instance.</main>